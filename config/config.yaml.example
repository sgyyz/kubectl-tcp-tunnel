# kubectl-tcp-tunnel Configuration File
# Copy this file to ~/.config/kubectl-tcp-tunnel/config.yaml and customize

# ==============================================================================
# GLOBAL SETTINGS
# ==============================================================================
# These settings apply to all environments unless overridden

settings:
  # Kubernetes namespace where jump pods will be created
  namespace: default

  # Docker image for the jump pod (must have socat installed)
  jump-pod-image: alpine/socat:latest

  # Timeout in seconds to wait for jump pod to become ready
  jump-pod-wait-timeout: 60

  # Connection type definitions (use YAML anchors for reusability)
  postgres: &postgres
    local-port: 15432
    db-port: 5432

  mysql: &mysql
    local-port: 13306
    db-port: 3306

  redis: &redis
    local-port: 16379
    db-port: 6379

  mongodb: &mongodb
    local-port: 17017
    db-port: 27017

# ==============================================================================
# ENVIRONMENTS
# ==============================================================================
# Define your environments with their Kubernetes contexts and connections

environments:
  # Staging environment
  staging:
    # Kubernetes context name (get with: kubectl config get-contexts)
    k8s-context: my-staging-cluster

    # TCP connections accessible from the staging cluster
    connections:
      user-db:
        host: user-db.staging.internal.example.com
        type: *postgres

      order-db:
        host: order-db.staging.internal.example.com
        type: *mysql

      cache:
        host: redis.staging.internal.example.com
        type: *redis

  # Production environment
  production:
    k8s-context: my-production-cluster

    connections:
      user-db:
        host: user-db.prod.internal.example.com
        type: *postgres

      order-db:
        host: order-db.prod.internal.example.com
        type: *mysql

      analytics-db:
        host: analytics-db.prod.internal.example.com
        type: *postgres

      cache:
        host: redis.prod.internal.example.com
        type: *redis

      sessions:
        host: mongodb.prod.internal.example.com
        type: *mongodb

  # Development environment (optional)
  dev:
    k8s-context: my-dev-cluster

    connections:
      main-db:
        host: postgres.dev.internal.example.com
        type: *postgres

# ==============================================================================
# CUSTOM CONNECTION TYPES
# ==============================================================================
# You can define custom connection types for specific ports:
#
# settings:
#   custom-service: &custom-service
#     local-port: 18080
#     db-port: 8080
#
# Then reference it in your connections:
#   connections:
#     my-service:
#       host: service.example.com
#       type: *custom-service

# ==============================================================================
# USAGE EXAMPLES
# ==============================================================================
#
# Once configured, use the plugin like this:
#
#   # Connect to staging user database (PostgreSQL) - short form
#   kubectl tcp-tunnel -e staging -c user-db
#
#   # Connect to production analytics database (PostgreSQL) - long form
#   kubectl tcp-tunnel --env production --connection analytics-db
#
#   # Connect to Redis cache - short form
#   kubectl tcp-tunnel -e staging -c cache
#
#   # Connect with custom local port - short form
#   kubectl tcp-tunnel -e staging -c order-db -p 3307
#
#   # Connect with custom local port - long form
#   kubectl tcp-tunnel --env staging --connection order-db --local-port 3307
#
#   # List all environments and connections
#   kubectl tcp-tunnel ls
#
#   # List connections for staging environment
#   kubectl tcp-tunnel ls staging
#
# ==============================================================================
# CUSTOMIZATION NOTES
# ==============================================================================
#
# 1. Update k8s-context values to match your kubectl contexts
#    Get your contexts with: kubectl config get-contexts
#
# 2. Update connection hostnames to match your actual service hosts
#    These hosts must be accessible from within your Kubernetes cluster
#
# 3. Define connection types with anchors (&name) and reference them (*name)
#    This makes it easy to manage port configurations
#
# 4. Add more environments and connections as needed
#    Supports PostgreSQL, MySQL, Redis, MongoDB, and any TCP service
#
# 5. Make sure your service account has permissions to create/delete pods
#    in the specified namespace
#
# For security:
# - Use read-only database users when possible
# - Use replica databases for analytics queries
# - Be careful with production database access
# - Consider using network policies to restrict jump pod access
#
# ==============================================================================
