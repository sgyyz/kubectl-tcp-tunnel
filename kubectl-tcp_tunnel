#!/usr/bin/env bash

set -euo pipefail

# kubectl-tcp-tunnel - A kubectl plugin for creating TCP tunnels through jump pods
# Version: v2.0.0
# This placeholder will be replaced during release

VERSION="${KUBECTL_TCP_TUNNEL_VERSION:-v2.0.3}"
SCRIPT_NAME="kubectl tcp-tunnel"
GITHUB_REPO="sgyyz/kubectl-tcp-tunnel"

# Default configuration path
CONFIG_FILE="${TCP_TUNNEL_CONFIG:-${HOME}/.config/kubectl-tcp-tunnel/config.yaml}"

# Default settings
DEFAULT_NAMESPACE="default"
DEFAULT_JUMP_POD_IMAGE="alpine/socat:latest"
DEFAULT_JUMP_POD_WAIT_TIMEOUT="60"
DEFAULT_LOCAL_PORT="5432"
DEFAULT_DB_PORT="5432"

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored output
print_error() {
    echo -e "${RED}âŒ ERROR:${NC} $*" >&2
}

print_success() {
    echo -e "${GREEN}âœ…${NC} $*"
}

print_info() {
    echo -e "${BLUE}ðŸ”µ${NC} $*"
}

print_warning() {
    echo -e "${YELLOW}âš ï¸${NC}  $*"
}

# Check if yq is installed
check_yq() {
    if ! command -v yq &> /dev/null; then
        print_error "yq is required but not installed"
        echo ""
        echo "Install yq:"
        echo "  macOS:   brew install yq"
        echo "  Linux:   See https://github.com/mikefarah/yq#install"
        echo ""
        exit 1
    fi
}

# Show help message
show_help() {
    cat <<EOF
${SCRIPT_NAME} - Create TCP tunnels through Kubernetes jump pods

USAGE:
    ${SCRIPT_NAME} -e <environment> -c <connection> [OPTIONS]
    ${SCRIPT_NAME} --env <environment> --connection <connection> [OPTIONS]
    ${SCRIPT_NAME} <SUBCOMMAND>

DESCRIPTION:
    This plugin creates a temporary jump pod in your Kubernetes cluster and
    forwards a local port to a remote TCP service (PostgreSQL, MySQL, Redis, etc.).
    It simplifies secure service access without exposing services directly.

OPTIONS:
    -e, --env <environment>       Environment to use (e.g., staging, production)
    -c, --connection <connection> Connection alias to use (supports any TCP service)
    -p, --local-port <port>       Local port to forward to (overrides connection type default)
    --help                        Show this help message
    --version                     Show version information

SUBCOMMANDS:
    ls [environment]       List available environments and connections
                           Optionally filter by environment
    edit-config            Open configuration file in \$EDITOR
    upgrade                Upgrade to the latest version
    uninstall              Uninstall kubectl-tcp-tunnel
    help                   Show this help message
    version                Show version information

EXAMPLES:
    # Create tunnel to staging PostgreSQL database
    ${SCRIPT_NAME} --env staging --connection user-db
    ${SCRIPT_NAME} -e staging -c user-db

    # Create tunnel to production MySQL with custom local port
    ${SCRIPT_NAME} --env production --connection order-db --local-port 3307
    ${SCRIPT_NAME} -e production -c order-db -p 3307

    # Create tunnel to Redis cache
    ${SCRIPT_NAME} -e staging -c cache

    # List all available environments and connections
    ${SCRIPT_NAME} ls

    # List connections for staging environment
    ${SCRIPT_NAME} ls staging

    # Edit configuration
    ${SCRIPT_NAME} edit-config

CONFIGURATION:
    Configuration file: ${CONFIG_FILE}

    Use 'edit-config' subcommand to edit your configuration.
    See config/config.yaml.example for documentation.

ENVIRONMENT VARIABLES:
    TCP_TUNNEL_CONFIG    Override default config file location

HOW IT WORKS:
    1. Switches to the appropriate Kubernetes context (via kubectx)
    2. Creates a temporary jump pod using alpine/socat
    3. Forwards local port to remote TCP service host:port
    4. Keeps the tunnel open until you press Ctrl+C
    5. Cleans up the jump pod on exit

For more information, visit: https://github.com/sgyyz/kubectl-tcp-tunnel
EOF
}

# Get latest version from GitHub
get_latest_version() {
    local latest_version=""

    if command -v curl >/dev/null 2>&1; then
        latest_version=$(curl -fsSL "https://api.github.com/repos/${GITHUB_REPO}/releases/latest" 2>/dev/null | grep '"tag_name"' | sed -E 's/.*"v?([^"]+)".*/\1/' || echo "")
    elif command -v wget >/dev/null 2>&1; then
        latest_version=$(wget -qO- "https://api.github.com/repos/${GITHUB_REPO}/releases/latest" 2>/dev/null | grep '"tag_name"' | sed -E 's/.*"v?([^"]+)".*/\1/' || echo "")
    fi

    echo "${latest_version}"
}

# Compare versions (returns 0 if v1 < v2, 1 if v1 >= v2)
version_lt() {
    local v1="$1"
    local v2="$2"

    # Remove 'v' prefix if present
    v1="${v1#v}"
    v2="${v2#v}"

    # Simple string comparison for now
    # This works for semantic versioning (e.g., 1.0.0, 1.2.3)
    if [[ "${v1}" == "${v2}" ]]; then
        return 1
    fi

    # Use sort -V to compare versions
    if printf '%s\n%s\n' "${v1}" "${v2}" | sort -V -C 2>/dev/null; then
        return 0
    else
        return 1
    fi
}

# Show version information
show_version() {
    local current_version="${VERSION#v}"
    echo "${SCRIPT_NAME} version ${current_version}"

    # Only check for updates if we have a real version (not v1.0.0 placeholder)
    if [[ "${VERSION}" != "v1.0.0" ]] && [[ -n "${VERSION}" ]]; then
        local latest_version
        latest_version=$(get_latest_version)

        if [[ -n "${latest_version}" ]]; then
            # shellcheck disable=SC2310
            if version_lt "${current_version}" "${latest_version}"; then
                echo ""
                print_warning "A newer version is available: ${latest_version}"
                echo ""
                echo "Update with: ${SCRIPT_NAME} upgrade"
            fi
        fi
    fi
}

# Load and validate configuration
load_config() {
    if [[ ! -f "${CONFIG_FILE}" ]]; then
        print_error "Configuration file not found: ${CONFIG_FILE}"
        echo ""
        echo "Please create a configuration file at the location above."
        echo "See config/config.yaml.example for an example."
        echo ""
        echo "You can also set PG_TUNNEL_CONFIG environment variable to use a different location."
        exit 1
    fi

    check_yq

    # Validate YAML syntax
    if ! yq eval '.' "${CONFIG_FILE}" &>/dev/null; then
        print_error "Invalid YAML syntax in config file: ${CONFIG_FILE}"
        exit 1
    fi
}

# Get setting from config with default fallback
get_setting() {
    local key="$1"
    local default="${2:-}"

    local value
    value=$(yq eval ".settings.${key} // \"\"" "${CONFIG_FILE}" 2>/dev/null)

    if [[ -z "${value}" ]] || [[ "${value}" == "null" ]]; then
        echo "${default}"
    else
        echo "${value}"
    fi
}

# Get environment context
get_env_context() {
    local env="$1"
    yq eval ".environments.${env}.k8s-context // \"\"" "${CONFIG_FILE}" 2>/dev/null
}

# Get connection host
get_db_host() {
    local env="$1"
    local db="$2"
    yq eval "explode(.) | .environments.${env}.connections.${db}.host // \"\"" "${CONFIG_FILE}" 2>/dev/null
}

# List all environments
list_environments() {
    yq eval '.environments | keys | .[]' "${CONFIG_FILE}" 2>/dev/null
}

# List connections for an environment
list_connections_for_env() {
    local env="$1"
    yq eval ".environments.${env}.connections | keys | .[]" "${CONFIG_FILE}" 2>/dev/null
}

# Get connection local-port (from type definition)
get_connection_local_port() {
    local env="$1"
    local conn="$2"
    yq eval "explode(.) | .environments.${env}.connections.${conn}.type.local-port // \"\"" "${CONFIG_FILE}" 2>/dev/null
}

# Get connection db-port (from type definition)
get_connection_db_port() {
    local env="$1"
    local conn="$2"
    yq eval "explode(.) | .environments.${env}.connections.${conn}.type.db-port // \"\"" "${CONFIG_FILE}" 2>/dev/null
}

# Generate random alphanumeric string (lowercase)
generate_random_suffix() {
    local length="${1:-6}"
    local suffix
    # Try to generate random suffix from /dev/urandom
    suffix=$(LC_ALL=C tr -dc 'a-z0-9' < /dev/urandom 2>/dev/null | head -c "${length}" || true)

    # Fallback to timestamp-based generation if urandom fails
    if [[ -z "${suffix}" ]] || [[ ${#suffix} -ne ${length} ]]; then
        local timestamp
        timestamp=$(date +%s)
        suffix=$(printf "%s" "${timestamp}" | sha256sum 2>/dev/null | head -c "${length}" || printf "%s" "${timestamp}" | head -c "${length}")
    fi

    echo "${suffix}"
}

# Get connection type name from config
get_connection_type() {
    local env="$1"
    local conn="$2"
    # Extract the type anchor name (e.g., *postgres -> postgres)
    local type_ref
    type_ref=$(yq eval ".environments.${env}.connections.${conn}.type" "${CONFIG_FILE}" 2>/dev/null | grep -o '\*[a-z0-9_-]*' | sed 's/^\*//' || echo "")
    echo "${type_ref}"
}

# Sanitize hostname to valid Kubernetes pod name
# Pod names must be lowercase alphanumeric with hyphens
sanitize_pod_name() {
    local name="$1"
    # Convert to lowercase, replace dots and underscores with hyphens
    # Remove any other invalid characters
    echo "${name}" | tr '[:upper:]' '[:lower:]' | tr '._' '-' | sed 's/[^a-z0-9-]//g'
}

# List available environments and databases
list_resources() {
    local filter_env="${1:-}"

    load_config

    echo "Available environments and connections:"
    echo ""

    local envs
    if [[ -n "${filter_env}" ]]; then
        envs="${filter_env}"
    else
        envs=$(list_environments)
    fi

    if [[ -z "${envs}" ]]; then
        print_warning "No environments configured"
        echo ""
        echo "Add environments to your config file: ${CONFIG_FILE}"
        return
    fi

    while IFS= read -r env; do
        [[ -z "${env}" ]] && continue

        local context
        context=$(get_env_context "${env}")

        echo "Environment: ${env}"
        echo "  Kubernetes context: ${context}"
        echo "  Connections:"

        local dbs
        dbs=$(list_connections_for_env "${env}")

        if [[ -z "${dbs}" ]]; then
            echo "    (no connections configured)"
        else
            while IFS= read -r db; do
                [[ -z "${db}" ]] && continue
                local host
                host=$(get_db_host "${env}" "${db}")
                echo "    - ${db}: ${host}"
            done <<< "${dbs}"
        fi
        echo ""
    done <<< "${envs}"
}

# Edit configuration file
edit_config() {
    local editor="${EDITOR:-vi}"

    if [[ ! -f "${CONFIG_FILE}" ]]; then
        print_warning "Configuration file does not exist: ${CONFIG_FILE}"
        read -p "Create it now? (y/n) " -n 1 -r
        echo
        if [[ ${REPLY} =~ ^[Yy]$ ]]; then
            mkdir -p "$(dirname "${CONFIG_FILE}")"

            # Create a basic config template
            cat > "${CONFIG_FILE}" <<'EOF'
# kubectl-tcp-tunnel configuration

settings:
  namespace: default
  jump-pod-image: alpine/socat:latest
  jump-pod-wait-timeout: 60

  # Connection type definitions with YAML anchors
  postgres: &postgres
    local-port: 15432
    db-port: 5432

  mysql: &mysql
    local-port: 13306
    db-port: 3306

  redis: &redis
    local-port: 16379
    db-port: 6379

environments:
  staging:
    k8s-context: my-staging-cluster
    connections:
      user-db:
        host: user-db.staging.example.com
        type: *postgres
      order-db:
        host: order-db.staging.example.com
        type: *mysql

  production:
    k8s-context: my-production-cluster
    connections:
      user-db:
        host: user-db.prod.example.com
        type: *postgres
      order-db:
        host: order-db.prod.example.com
        type: *mysql
EOF
            print_success "Created example config file"
        else
            exit 1
        fi
    fi

    print_info "Opening configuration file in ${editor}..."
    "${editor}" "${CONFIG_FILE}"
}

# Upgrade function
upgrade_plugin() {
    print_info "Upgrading kubectl-tcp-tunnel..."
    echo ""

    # Check if we have curl or wget
    if command -v curl >/dev/null 2>&1; then
        print_info "Downloading and running installer..."
        # shellcheck disable=SC2312
        if FORCE_INSTALL=1 bash -c "$(curl -fsSL https://raw.githubusercontent.com/sgyyz/kubectl-tcp-tunnel/main/install.sh)"; then
            echo ""
            print_success "Upgrade completed successfully!"
            echo ""
            print_info "Your configuration has been preserved at: ${CONFIG_FILE}"
        else
            print_error "Upgrade failed"
            exit 1
        fi
    elif command -v wget >/dev/null 2>&1; then
        print_info "Downloading and running installer..."
        # shellcheck disable=SC2312
        if FORCE_INSTALL=1 bash -c "$(wget -qO- https://raw.githubusercontent.com/sgyyz/kubectl-tcp-tunnel/main/install.sh)"; then
            echo ""
            print_success "Upgrade completed successfully!"
            echo ""
            print_info "Your configuration has been preserved at: ${CONFIG_FILE}"
        else
            print_error "Upgrade failed"
            exit 1
        fi
    else
        print_error "Neither curl nor wget found"
        echo ""
        echo "Please install curl or wget and try again:"
        echo "  macOS:  brew install curl"
        echo "  Linux:  sudo apt-get install curl"
        exit 1
    fi
}

# Uninstall function
uninstall_plugin() {
    print_info "Uninstalling kubectl-tcp-tunnel..."
    echo ""

    # Check if we have curl or wget
    if command -v curl >/dev/null 2>&1; then
        print_info "Downloading and running uninstaller..."
        if curl -fsSL https://raw.githubusercontent.com/sgyyz/kubectl-tcp-tunnel/main/uninstall.sh | bash; then
            echo ""
            print_success "Uninstall completed!"
        else
            print_error "Uninstall failed"
            exit 1
        fi
    elif command -v wget >/dev/null 2>&1; then
        print_info "Downloading and running uninstaller..."
        if wget -qO- https://raw.githubusercontent.com/sgyyz/kubectl-tcp-tunnel/main/uninstall.sh | bash; then
            echo ""
            print_success "Uninstall completed!"
        else
            print_error "Uninstall failed"
            exit 1
        fi
    else
        print_error "Neither curl nor wget found"
        echo ""
        echo "Please install curl or wget and try again:"
        echo "  macOS:  brew install curl"
        echo "  Linux:  sudo apt-get install curl"
        exit 1
    fi
}

# Cleanup function
cleanup() {
    local pod_name="$1"
    local context="$2"
    local namespace="$3"

    print_info "Cleaning up..."

    # Delete the jump pod
    if kubectl --context="${context}" -n "${namespace}" get pod "${pod_name}" &>/dev/null; then
        kubectl --context="${context}" -n "${namespace}" delete pod "${pod_name}" --grace-period=0 --force &>/dev/null || true
        print_success "Deleted jump pod: ${pod_name}"
    fi
}

# Create tunnel
create_tunnel() {
    local environment="$1"
    local database="$2"
    local local_port="$3"

    load_config

    # Get settings
    local namespace
    local jump_pod_image
    local jump_pod_wait_timeout
    local db_port

    namespace=$(get_setting "namespace" "${DEFAULT_NAMESPACE}")
    jump_pod_image=$(get_setting "jump-pod-image" "${DEFAULT_JUMP_POD_IMAGE}")
    jump_pod_wait_timeout=$(get_setting "jump-pod-wait-timeout" "${DEFAULT_JUMP_POD_WAIT_TIMEOUT}")

    # Try to get db-port from connection type definition first
    db_port=$(get_connection_db_port "${environment}" "${database}")

    # If not found in connection type, fall back to global setting
    if [[ -z "${db_port}" ]] || [[ "${db_port}" == "null" ]]; then
        db_port=$(get_setting "db-port" "${DEFAULT_DB_PORT}")
    fi

    # Get environment context
    local context
    context=$(get_env_context "${environment}")

    if [[ -z "${context}" ]] || [[ "${context}" == "null" ]]; then
        print_error "Unknown environment: ${environment}"
        echo ""
        echo "Available environments:"
        list_environments | sed 's/^/  - /'
        echo ""
        echo "Add environments to your config file: ${CONFIG_FILE}"
        exit 1
    fi

    # Get database host
    local db_host
    db_host=$(get_db_host "${environment}" "${database}")

    if [[ -z "${db_host}" ]] || [[ "${db_host}" == "null" ]]; then
        print_error "Unknown connection: ${database} in environment: ${environment}"
        echo ""
        echo "Available connections for ${environment}:"
        list_connections_for_env "${environment}" | sed 's/^/  - /'
        echo ""
        echo "Add connections to your config file: ${CONFIG_FILE}"
        exit 1
    fi

    # Generate pod name with connection type prefix and random suffix
    local connection_type
    connection_type=$(get_connection_type "${environment}" "${database}")

    local random_suffix
    random_suffix=$(generate_random_suffix 6)

    local pod_name
    if [[ -n "${connection_type}" ]] && [[ "${connection_type}" != "null" ]]; then
        # Use connection type as prefix (e.g., postgres-tunnel-a1b2c3)
        pod_name="${connection_type}-tunnel-${random_suffix}"
    else
        # Fallback to generic name (e.g., tcp-tunnel-a1b2c3)
        pod_name="tcp-tunnel-${random_suffix}"
    fi

    print_info "Environment: ${environment}"
    print_info "Context: ${context}"
    print_info "Connection: ${database} (${db_host})"
    print_info "Namespace: ${namespace}"
    print_info "Jump pod: ${pod_name}"
    print_info "Local port: ${local_port}"
    print_info "Remote port: ${db_port}"
    echo ""

    # Set up cleanup trap with current values
    # We want the variables to expand now, not when the trap fires
    # shellcheck disable=SC2064
    trap "cleanup '${pod_name}' '${context}' '${namespace}'" EXIT INT TERM

    # Switch context
    print_info "Switching to context: ${context}..."
    if ! kubectx "${context}" >/dev/null 2>&1; then
        print_error "Failed to switch to context: ${context}"
        exit 1
    fi
    print_success "Switched to context: ${context}"

    # Check if pod already exists
    if kubectl --context="${context}" -n "${namespace}" get pod "${pod_name}" &>/dev/null; then
        print_warning "Jump pod already exists: ${pod_name}"
        print_info "Deleting existing pod..."
        kubectl --context="${context}" -n "${namespace}" delete pod "${pod_name}" --grace-period=0 --force >/dev/null 2>&1 || true
        sleep 2
    fi

    # Create jump pod
    print_info "Creating jump pod..."
    if ! kubectl --context="${context}" -n "${namespace}" run "${pod_name}" \
        --image="${jump_pod_image}" \
        --restart=Never \
        --command -- socat TCP-LISTEN:5432,fork,reuseaddr TCP:"${db_host}":"${db_port}"; then
        print_error "Failed to create jump pod"
        exit 1
    fi
    print_success "Created jump pod: ${pod_name}"

    # Wait for pod to be ready
    print_info "Waiting for pod to be ready (timeout: ${jump_pod_wait_timeout}s)..."
    if ! kubectl --context="${context}" -n "${namespace}" wait pod/"${pod_name}" \
        --for=condition=Ready \
        --timeout="${jump_pod_wait_timeout}s" >/dev/null 2>&1; then
        print_error "Pod failed to become ready within ${jump_pod_wait_timeout}s"
        print_info "Pod status:"
        kubectl --context="${context}" -n "${namespace}" describe pod "${pod_name}" | tail -20
        exit 1
    fi
    print_success "Pod is ready"

    # Start port forwarding
    echo ""
    print_success "Tunnel established!"
    print_info "Local:  localhost:${local_port}"
    print_info "Remote: ${db_host}:${db_port}"
    echo ""
    print_info "You can now connect to localhost:${local_port}"
    echo ""
    print_warning "Press Ctrl+C to stop the tunnel and clean up"
    echo ""

    # Port forward (this blocks until Ctrl+C)
    kubectl --context="${context}" -n "${namespace}" port-forward pod/"${pod_name}" "${local_port}":5432
}

# Main function
main() {
    # Handle no arguments
    if [[ $# -eq 0 ]]; then
        show_help
        exit 0
    fi

    # Parse arguments
    local environment=""
    local database=""
    local local_port=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --help|help)
                show_help
                exit 0
                ;;
            --version|version)
                show_version
                exit 0
                ;;
            ls)
                shift
                if [[ $# -gt 0 ]] && [[ ! "$1" =~ ^- ]]; then
                    list_resources "$1"
                else
                    list_resources
                fi
                exit 0
                ;;
            edit-config)
                edit_config
                exit 0
                ;;
            upgrade)
                upgrade_plugin
                exit 0
                ;;
            uninstall)
                uninstall_plugin
                exit 0
                ;;
            --env|-e)
                if [[ $# -lt 2 ]]; then
                    print_error "Option --env/-e requires an environment argument"
                    exit 1
                fi
                environment="$2"
                shift 2
                ;;
            --connection|-c)
                if [[ $# -lt 2 ]]; then
                    print_error "Option --connection/-c requires a connection argument"
                    exit 1
                fi
                database="$2"
                shift 2
                ;;
            --local-port|-p)
                if [[ $# -lt 2 ]]; then
                    print_error "Option --local-port/-p requires a port argument"
                    exit 1
                fi
                local_port="$2"
                shift 2
                ;;
            -*)
                print_error "Unknown option: $1"
                echo ""
                echo "Use '${SCRIPT_NAME} --help' for usage information"
                exit 1
                ;;
            *)
                print_error "Unexpected argument: $1"
                echo ""
                echo "Use '${SCRIPT_NAME} --help' for usage information"
                exit 1
                ;;
        esac
    done

    # Validate required arguments for tunnel creation
    if [[ -z "${environment}" ]]; then
        print_error "Missing required option: -e/--env <environment>"
        echo ""
        echo "Usage: ${SCRIPT_NAME} -e <environment> -c <connection>"
        echo "   or: ${SCRIPT_NAME} --env <environment> --connection <connection>"
        echo ""
        echo "Use '${SCRIPT_NAME} ls' to see available environments"
        exit 1
    fi

    if [[ -z "${database}" ]]; then
        print_error "Missing required option: -c/--connection <connection>"
        echo ""
        echo "Usage: ${SCRIPT_NAME} -e <environment> -c <connection>"
        echo "   or: ${SCRIPT_NAME} --env <environment> --connection <connection>"
        echo ""
        echo "Use '${SCRIPT_NAME} ls ${environment}' to see available connections"
        exit 1
    fi

    # If local_port not specified via flag, read from config or use default
    if [[ -z "${local_port}" ]]; then
        load_config
        # Try to get local-port from connection type definition first
        local_port=$(get_connection_local_port "${environment}" "${database}")

        # If not found in connection type, fall back to global setting
        if [[ -z "${local_port}" ]] || [[ "${local_port}" == "null" ]]; then
            local_port=$(get_setting "local-port" "${DEFAULT_LOCAL_PORT}")
        fi
    fi

    # Create the tunnel
    create_tunnel "${environment}" "${database}" "${local_port}"
}

# Run main function
main "$@"
