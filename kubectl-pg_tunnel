#!/usr/bin/env bash

set -euo pipefail

# kubectl-pg-tunnel - A kubectl plugin for creating PostgreSQL tunnels through jump pods
# Version: 1.0.0

VERSION="1.0.0"
SCRIPT_NAME="kubectl pg-tunnel"

# Default configuration path
CONFIG_FILE="${PG_TUNNEL_CONFIG:-${HOME}/.config/kubectl-pg-tunnel/config.yaml}"

# Default settings
DEFAULT_NAMESPACE="default"
DEFAULT_JUMP_POD_IMAGE="alpine/socat:latest"
DEFAULT_JUMP_POD_WAIT_TIMEOUT="60"
DEFAULT_LOCAL_PORT="5432"
DEFAULT_DB_PORT="5432"

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored output
print_error() {
    echo -e "${RED}ERROR:${NC} $*" >&2
}

print_success() {
    echo -e "${GREEN}✓${NC} $*"
}

print_info() {
    echo -e "${BLUE}→${NC} $*"
}

print_warning() {
    echo -e "${YELLOW}⚠${NC} $*"
}

# Check if yq is installed
check_yq() {
    if ! command -v yq &> /dev/null; then
        print_error "yq is required but not installed"
        echo ""
        echo "Install yq:"
        echo "  macOS:   brew install yq"
        echo "  Linux:   See https://github.com/mikefarah/yq#install"
        echo ""
        exit 1
    fi
}

# Show help message
show_help() {
    cat <<EOF
${SCRIPT_NAME} - Create PostgreSQL tunnels through Kubernetes jump pods

USAGE:
    ${SCRIPT_NAME} --env <environment> --db <database> [OPTIONS]
    ${SCRIPT_NAME} <SUBCOMMAND>

DESCRIPTION:
    This plugin creates a temporary jump pod in your Kubernetes cluster and
    forwards a local port to a remote PostgreSQL database. It simplifies
    secure database access without exposing databases directly.

OPTIONS:
    --env <environment>    Environment to use (e.g., staging, production)
    --db <database>        Database alias to connect to
    --local-port <port>    Local port to forward to (default: 5432)
    --help                 Show this help message
    --version              Show version information

SUBCOMMANDS:
    ls [environment]       List available environments and databases
                           Optionally filter by environment
    edit-config            Open configuration file in \$EDITOR
    upgrade                Upgrade to the latest version
    uninstall              Uninstall kubectl-pg-tunnel
    help                   Show this help message
    version                Show version information

EXAMPLES:
    # Create tunnel to staging user database
    ${SCRIPT_NAME} --env staging --db user-db

    # Create tunnel to production with custom local port
    ${SCRIPT_NAME} --env production --db order-db --local-port 5433

    # List all available environments and databases
    ${SCRIPT_NAME} ls

    # List databases for staging environment
    ${SCRIPT_NAME} ls staging

    # Edit configuration
    ${SCRIPT_NAME} edit-config

CONFIGURATION:
    Configuration file: ${CONFIG_FILE}

    Use 'edit-config' subcommand to edit your configuration.
    See config/config.yaml.example for documentation.

ENVIRONMENT VARIABLES:
    PG_TUNNEL_CONFIG    Override default config file location

HOW IT WORKS:
    1. Switches to the appropriate Kubernetes context (via kubectx)
    2. Creates a temporary jump pod using alpine/socat
    3. Forwards local port to remote PostgreSQL host:port
    4. Keeps the tunnel open until you press Ctrl+C
    5. Cleans up the jump pod on exit

For more information, visit: https://github.com/yourusername/kubectl-pg-tunnel
EOF
}

# Show version information
show_version() {
    echo "${SCRIPT_NAME} version ${VERSION}"
}

# Load and validate configuration
load_config() {
    if [[ ! -f "${CONFIG_FILE}" ]]; then
        print_error "Configuration file not found: ${CONFIG_FILE}"
        echo ""
        echo "Please create a configuration file at the location above."
        echo "See config/config.yaml.example for an example."
        echo ""
        echo "You can also set PG_TUNNEL_CONFIG environment variable to use a different location."
        exit 1
    fi

    check_yq

    # Validate YAML syntax
    if ! yq eval '.' "${CONFIG_FILE}" &>/dev/null; then
        print_error "Invalid YAML syntax in config file: ${CONFIG_FILE}"
        exit 1
    fi
}

# Get setting from config with default fallback
get_setting() {
    local key="$1"
    local default="${2:-}"

    local value
    value=$(yq eval ".settings.${key} // \"\"" "${CONFIG_FILE}" 2>/dev/null)

    if [[ -z "${value}" ]] || [[ "${value}" == "null" ]]; then
        echo "${default}"
    else
        echo "${value}"
    fi
}

# Get environment context
get_env_context() {
    local env="$1"
    yq eval ".environments.${env}.k8s-context // \"\"" "${CONFIG_FILE}" 2>/dev/null
}

# Get database host
get_db_host() {
    local env="$1"
    local db="$2"
    yq eval ".environments.${env}.databases.${db} // \"\"" "${CONFIG_FILE}" 2>/dev/null
}

# List all environments
list_environments() {
    yq eval '.environments | keys | .[]' "${CONFIG_FILE}" 2>/dev/null
}

# List databases for an environment
list_databases_for_env() {
    local env="$1"
    yq eval ".environments.${env}.databases | keys | .[]" "${CONFIG_FILE}" 2>/dev/null
}

# Sanitize hostname to valid Kubernetes pod name
# Pod names must be lowercase alphanumeric with hyphens
sanitize_pod_name() {
    local name="$1"
    # Convert to lowercase, replace dots and underscores with hyphens
    # Remove any other invalid characters
    echo "${name}" | tr '[:upper:]' '[:lower:]' | tr '._' '-' | sed 's/[^a-z0-9-]//g'
}

# List available environments and databases
list_resources() {
    local filter_env="${1:-}"

    load_config

    echo "Available environments and databases:"
    echo ""

    local envs
    if [[ -n "${filter_env}" ]]; then
        envs="${filter_env}"
    else
        envs=$(list_environments)
    fi

    if [[ -z "${envs}" ]]; then
        print_warning "No environments configured"
        echo ""
        echo "Add environments to your config file: ${CONFIG_FILE}"
        return
    fi

    while IFS= read -r env; do
        [[ -z "${env}" ]] && continue

        local context
        context=$(get_env_context "${env}")

        echo "Environment: ${env}"
        echo "  Kubernetes context: ${context}"
        echo "  Databases:"

        local dbs
        dbs=$(list_databases_for_env "${env}")

        if [[ -z "${dbs}" ]]; then
            echo "    (no databases configured)"
        else
            while IFS= read -r db; do
                [[ -z "${db}" ]] && continue
                local host
                host=$(get_db_host "${env}" "${db}")
                echo "    - ${db}: ${host}"
            done <<< "${dbs}"
        fi
        echo ""
    done <<< "${envs}"
}

# Edit configuration file
edit_config() {
    local editor="${EDITOR:-vi}"

    if [[ ! -f "${CONFIG_FILE}" ]]; then
        print_warning "Configuration file does not exist: ${CONFIG_FILE}"
        read -p "Create it now? (y/n) " -n 1 -r
        echo
        if [[ ${REPLY} =~ ^[Yy]$ ]]; then
            mkdir -p "$(dirname "${CONFIG_FILE}")"

            # Create a basic config template
            cat > "${CONFIG_FILE}" <<'EOF'
# kubectl-pg-tunnel configuration

settings:
  namespace: default
  jump-pod-image: alpine/socat:latest
  jump-pod-wait-timeout: 60
  local-port: 5432
  db-port: 5432

environments:
  staging:
    k8s-context: my-staging-cluster
    databases:
      user-db: user-db.staging.example.com
      order-db: order-db.staging.example.com

  production:
    k8s-context: my-production-cluster
    databases:
      user-db: user-db.prod.example.com
      order-db: order-db.prod.example.com
EOF
            print_success "Created example config file"
        else
            exit 1
        fi
    fi

    print_info "Opening configuration file in ${editor}..."
    "${editor}" "${CONFIG_FILE}"
}

# Upgrade function
upgrade_plugin() {
    print_info "Upgrading kubectl-pg-tunnel..."
    echo ""

    # Check if we have curl or wget
    if command -v curl >/dev/null 2>&1; then
        print_info "Downloading and running installer..."
        if curl -fsSL https://raw.githubusercontent.com/sgyyz/kubectl-pg-tunnel/main/install.sh | bash; then
            echo ""
            print_success "Upgrade completed successfully!"
            echo ""
            print_info "Your configuration has been preserved at: ${CONFIG_FILE}"
        else
            print_error "Upgrade failed"
            exit 1
        fi
    elif command -v wget >/dev/null 2>&1; then
        print_info "Downloading and running installer..."
        if wget -qO- https://raw.githubusercontent.com/sgyyz/kubectl-pg-tunnel/main/install.sh | bash; then
            echo ""
            print_success "Upgrade completed successfully!"
            echo ""
            print_info "Your configuration has been preserved at: ${CONFIG_FILE}"
        else
            print_error "Upgrade failed"
            exit 1
        fi
    else
        print_error "Neither curl nor wget found"
        echo ""
        echo "Please install curl or wget and try again:"
        echo "  macOS:  brew install curl"
        echo "  Linux:  sudo apt-get install curl"
        exit 1
    fi
}

# Uninstall function
uninstall_plugin() {
    print_info "Uninstalling kubectl-pg-tunnel..."
    echo ""

    # Check if we have curl or wget
    if command -v curl >/dev/null 2>&1; then
        print_info "Downloading and running uninstaller..."
        if curl -fsSL https://raw.githubusercontent.com/sgyyz/kubectl-pg-tunnel/main/uninstall.sh | bash; then
            echo ""
            print_success "Uninstall completed!"
        else
            print_error "Uninstall failed"
            exit 1
        fi
    elif command -v wget >/dev/null 2>&1; then
        print_info "Downloading and running uninstaller..."
        if wget -qO- https://raw.githubusercontent.com/sgyyz/kubectl-pg-tunnel/main/uninstall.sh | bash; then
            echo ""
            print_success "Uninstall completed!"
        else
            print_error "Uninstall failed"
            exit 1
        fi
    else
        print_error "Neither curl nor wget found"
        echo ""
        echo "Please install curl or wget and try again:"
        echo "  macOS:  brew install curl"
        echo "  Linux:  sudo apt-get install curl"
        exit 1
    fi
}

# Cleanup function
cleanup() {
    local pod_name="$1"
    local context="$2"
    local namespace="$3"

    print_info "Cleaning up..."

    # Delete the jump pod
    if kubectl --context="${context}" -n "${namespace}" get pod "${pod_name}" &>/dev/null; then
        kubectl --context="${context}" -n "${namespace}" delete pod "${pod_name}" --grace-period=0 --force &>/dev/null || true
        print_success "Deleted jump pod: ${pod_name}"
    fi
}

# Create tunnel
create_tunnel() {
    local environment="$1"
    local database="$2"
    local local_port="$3"

    load_config

    # Get settings
    local namespace
    local jump_pod_image
    local jump_pod_wait_timeout
    local db_port

    namespace=$(get_setting "namespace" "${DEFAULT_NAMESPACE}")
    jump_pod_image=$(get_setting "jump-pod-image" "${DEFAULT_JUMP_POD_IMAGE}")
    jump_pod_wait_timeout=$(get_setting "jump-pod-wait-timeout" "${DEFAULT_JUMP_POD_WAIT_TIMEOUT}")
    db_port=$(get_setting "db-port" "${DEFAULT_DB_PORT}")

    # Get environment context
    local context
    context=$(get_env_context "${environment}")

    if [[ -z "${context}" ]] || [[ "${context}" == "null" ]]; then
        print_error "Unknown environment: ${environment}"
        echo ""
        echo "Available environments:"
        list_environments | sed 's/^/  - /'
        echo ""
        echo "Add environments to your config file: ${CONFIG_FILE}"
        exit 1
    fi

    # Get database host
    local db_host
    db_host=$(get_db_host "${environment}" "${database}")

    if [[ -z "${db_host}" ]] || [[ "${db_host}" == "null" ]]; then
        print_error "Unknown database: ${database} in environment: ${environment}"
        echo ""
        echo "Available databases for ${environment}:"
        list_databases_for_env "${environment}" | sed 's/^/  - /'
        echo ""
        echo "Add databases to your config file: ${CONFIG_FILE}"
        exit 1
    fi

    # Generate pod name
    local sanitized_db
    sanitized_db=$(sanitize_pod_name "${database}")
    local pod_name="pg-jump-${sanitized_db}"

    print_info "Environment: ${environment}"
    print_info "Context: ${context}"
    print_info "Database: ${database} (${db_host})"
    print_info "Namespace: ${namespace}"
    print_info "Jump pod: ${pod_name}"
    print_info "Local port: ${local_port}"
    print_info "Remote port: ${db_port}"
    echo ""

    # Set up cleanup trap with current values
    # We want the variables to expand now, not when the trap fires
    # shellcheck disable=SC2064
    trap "cleanup '${pod_name}' '${context}' '${namespace}'" EXIT INT TERM

    # Switch context
    print_info "Switching to context: ${context}..."
    if ! kubectx "${context}" >/dev/null 2>&1; then
        print_error "Failed to switch to context: ${context}"
        exit 1
    fi
    print_success "Switched to context: ${context}"

    # Check if pod already exists
    if kubectl --context="${context}" -n "${namespace}" get pod "${pod_name}" &>/dev/null; then
        print_warning "Jump pod already exists: ${pod_name}"
        print_info "Deleting existing pod..."
        kubectl --context="${context}" -n "${namespace}" delete pod "${pod_name}" --grace-period=0 --force >/dev/null 2>&1 || true
        sleep 2
    fi

    # Create jump pod
    print_info "Creating jump pod..."
    if ! kubectl --context="${context}" -n "${namespace}" run "${pod_name}" \
        --image="${jump_pod_image}" \
        --restart=Never \
        --command -- socat TCP-LISTEN:5432,fork,reuseaddr TCP:"${db_host}":"${db_port}"; then
        print_error "Failed to create jump pod"
        exit 1
    fi
    print_success "Created jump pod: ${pod_name}"

    # Wait for pod to be ready
    print_info "Waiting for pod to be ready (timeout: ${jump_pod_wait_timeout}s)..."
    if ! kubectl --context="${context}" -n "${namespace}" wait pod/"${pod_name}" \
        --for=condition=Ready \
        --timeout="${jump_pod_wait_timeout}s" >/dev/null 2>&1; then
        print_error "Pod failed to become ready within ${jump_pod_wait_timeout}s"
        print_info "Pod status:"
        kubectl --context="${context}" -n "${namespace}" describe pod "${pod_name}" | tail -20
        exit 1
    fi
    print_success "Pod is ready"

    # Start port forwarding
    echo ""
    print_success "Tunnel established!"
    print_info "Local:  localhost:${local_port}"
    print_info "Remote: ${db_host}:${db_port}"
    echo ""
    print_info "Connect with: psql -h localhost -p ${local_port} -U <username> <database>"
    echo ""
    print_warning "Press Ctrl+C to stop the tunnel and clean up"
    echo ""

    # Port forward (this blocks until Ctrl+C)
    kubectl --context="${context}" -n "${namespace}" port-forward pod/"${pod_name}" "${local_port}":5432
}

# Main function
main() {
    # Handle no arguments
    if [[ $# -eq 0 ]]; then
        show_help
        exit 0
    fi

    # Parse arguments
    local environment=""
    local database=""
    local local_port=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --help|help)
                show_help
                exit 0
                ;;
            --version|version)
                show_version
                exit 0
                ;;
            ls)
                shift
                if [[ $# -gt 0 ]] && [[ ! "$1" =~ ^- ]]; then
                    list_resources "$1"
                else
                    list_resources
                fi
                exit 0
                ;;
            edit-config)
                edit_config
                exit 0
                ;;
            upgrade)
                upgrade_plugin
                exit 0
                ;;
            uninstall)
                uninstall_plugin
                exit 0
                ;;
            --env)
                if [[ $# -lt 2 ]]; then
                    print_error "Option --env requires an environment argument"
                    exit 1
                fi
                environment="$2"
                shift 2
                ;;
            --db)
                if [[ $# -lt 2 ]]; then
                    print_error "Option --db requires a database argument"
                    exit 1
                fi
                database="$2"
                shift 2
                ;;
            --local-port)
                if [[ $# -lt 2 ]]; then
                    print_error "Option --local-port requires a port argument"
                    exit 1
                fi
                local_port="$2"
                shift 2
                ;;
            -*)
                print_error "Unknown option: $1"
                echo ""
                echo "Use '${SCRIPT_NAME} --help' for usage information"
                exit 1
                ;;
            *)
                print_error "Unexpected argument: $1"
                echo ""
                echo "Use '${SCRIPT_NAME} --help' for usage information"
                exit 1
                ;;
        esac
    done

    # Validate required arguments for tunnel creation
    if [[ -z "${environment}" ]]; then
        print_error "Missing required option: --env <environment>"
        echo ""
        echo "Usage: ${SCRIPT_NAME} --env <environment> --db <database>"
        echo ""
        echo "Use '${SCRIPT_NAME} ls' to see available environments"
        exit 1
    fi

    if [[ -z "${database}" ]]; then
        print_error "Missing required option: --db <database>"
        echo ""
        echo "Usage: ${SCRIPT_NAME} --env <environment> --db <database>"
        echo ""
        echo "Use '${SCRIPT_NAME} ls ${environment}' to see available databases"
        exit 1
    fi

    # If local_port not specified via flag, read from config or use default
    if [[ -z "${local_port}" ]]; then
        load_config
        local_port=$(get_setting "local-port" "${DEFAULT_LOCAL_PORT}")
    fi

    # Create the tunnel
    create_tunnel "${environment}" "${database}" "${local_port}"
}

# Run main function
main "$@"
